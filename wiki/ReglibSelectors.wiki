#summary How reglib's selectors work

=The API=

`reglib` has a simple Selector API. Supposing you first executed this code:

{{{
var myElement = document.getElementById('baz');
}}}

The following demonstrates the entirety of what's possible with the Selector API.

{{{
var sel = new Selector('div#foo ul > li.bar');
if (sel.matches(myElement)) { ... }
}}}

This is just documented for posterity. You shouldn't ever need to use this API directly. `reg` functions and methods always accept plain selector strings and will convert them internally to Selector objects, often caching the compiled versions for future use.

=Selector Syntax=

|| *Selector* || *What it Selects* ||
|| `a` || `a` elements ||
|| `a span` || `span` elements descended from `a` elements ||
|| `a > span` || `span` elements that are direct children of `a` elements ||
|| `a + span` || `span` elements that are immediate next siblings of `a` elements ||
|| `a ~ span` || `span` elements that are following siblings of `a` elements ||
|| `a, span` || any `span` or `a` element ||
|| `a@title` || `a` elements having title attributes ||
|| `a@title='foo'` || `a` elements whose title attributes equal `foo` ||
|| `a@title^='foo'` || `a` elements whose title attributes begin with `foo` ||
|| `a@title*='foo'` || `a` elements whose title attributes contain `foo` ||
|| `a@title$='foo'` || `a` elements whose title attributes end with `foo` ||
|| `a@title!='foo'` || `a` elements whose title attributes do not equal `foo` ||
|| `a#foo` || `a` elements whose id equals `foo` ||
|| `a.foo` || `a` elements whose class attributes equal `foo`, or contain `foo` in a space-separated list ||
|| `a:target` || `a` elements whose id matches the URL hash ||
|| `#foo` or `*#foo` || any element with an id that equals `foo` ||
|| `.foo` or `*.foo` || any element with a class attribute that equals `foo`, or contains `foo` in a space-separated list ||
|| `:target` or `*:target` || any element whose id matches the URL hash ||